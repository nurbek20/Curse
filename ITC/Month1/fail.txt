**installing psql
1.sudo apt update
2.sudo apt install postgresql postgresql-contrib
3.service postgresql status




****Основные команды PostgreSQL****
\du – список пользователей
\dt – список таблиц
\d “table_name” – описание таблицы
\l – список баз данных
\q (или Ctrl+D) – выход с программы
\? – справочник psql
\help – справочник SQL
exit, logout = выход из интерактивного режима

**Получить дополнительный контроль с помощью дополнительных флагов. 
1.man createuser

**Доступ к командной строке Postgres без переключения учетных записей
1. sudo -u postgres psql  



**После входа вы можете проверить данные о текущем подключении:
1. \conninfo

** Создание новой базы данных
1. createdb sammy


** Удаление базы данных
1. dropdb sammy



**Создание новой роли
1.CREATE USER admin WITH PASSWORD 'admin';

**Изменить пароль у роли admin
1. ALTER USER admin WITH PASSWORD 'new_password';



**Изменить статус роли admin на SUPERUSER
1. ALTER USER admin WITH SUPERUSER;

**Удалить роли admin
1. DROP USER admin;


Вот настоящий запрос на создание таблицы:
-- СОЗДАТЬ ТАБЛИЦУ с названием author
CREATE TABLE author(
    id    INTEGER PRIMARY KEY, 
    -- создать колонку с названием id, в ней будут ЦЕЛЫЕ ЧИСЛА, 
    -- в этой колонке будут храниться УНИКАЛЬНЫЕ КЛЮЧИ записей
    name  TEXT NOT NULL,
    -- создать колонку с названием name, в ней будет ТЕКСТ 
    -- и НЕ МОЖЕТ БЫТЬ ПУСТОЙ
    birth_year INTEGER
    -- создать колонку с названием birth_year, в ней будут ЦЕЛЫЕ ЧИСЛА
);




























***************************************************************************
CRUD создать, прочитать, обновить, удалить
После создания таблицы в нее можно добавлять записи. Проще всего представлять себе, что каждая новая запись — это строка, а поля — это ячейки таблицы.
Операции с данным часто именуют сокращением CRUD:
Create — создать запись
Read — прочитать данные
Update — обновить запись
Delete — удалить запись
Добавление записей: INSERT
Синтаксис добавления новой записи в таблицу выглядит так:
INSERT INTO <имя таблицы> (<имя столбца>[, <имя столбца2>, ...])
VALUES (<значение>[, <значение2>, ...]);
Для того чтобы добавить несколько записей — отправим несколько запросов INSERT («вставить»):
INSERT INTO author (name, birth_year) VALUES ('Человек без селезёнки', 1860);
-- ВСТАВИТЬ строку В ТАБЛИЦУ author
-- заполнить поля (name, birth_year) ЗНАЧЕНИЯМИ 'Человек без селезёнки', 1860 соответственно

INSERT INTO author (id, name, birth_year) VALUES (1, 'Владимир Набоков', 1899);
INSERT INTO author (id, name, birth_year) VALUES (2, 'Лев Толстой', 1828);
INSERT INTO author (id, name, birth_year) VALUES (3, 'Насон Грядущий', 3019);
INSERT INTO author (id, name, birth_year) VALUES (4, 'Юрий Олеша', 1899);
INSERT INTO author (id, name, birth_year) VALUES (5, 'Николай Чернышевский', 1828);
INSERT INTO author (id, name, birth_year) VALUES (6, 'Андрей Платонов', 1899);
Пусть база сама присваивает номера уникальных ключей, для поля id передавать значения мы не будем.
Чтение записей: SELECT
Синтаксис запросов на чтение:
SELECT 
    <перечень столбцов>
FROM
    <перечень таблиц>
WHERE
    <условия>;
В ответ на запрос SELECT данные возвращаются в структурированном табличном виде. Чтобы не путаться в понятиях «таблица БД» и «таблица с ответом» будем называть возвращаемые данные «результирующая выборка».
Прочитаем записи которые мы добавили в таблицу:
-- ВЫБРАТЬ поля id, name, birth_year
SELECT
    id,
    name,
    birth_year
-- ИЗ ТАБЛИЦЫ author
FROM
    author;
Если нам нужно получить все поля, то вместо их перечисления можно использовать символ *:
SELECT * FROM author;
Этот запрос вернёт результат:
-- ВЫБРАТЬ данные из всех колонок ИЗ ТАБЛИЦЫ author
SELECT * FROM author; 

-- Ответ (вот ты какая, «результирующая выборка»!):
id     name                  birth_year
-----  --------------------  ------------
1      Человек без селезёнки 1860
2      Владимир Набоков      1899
3      Лев Толстой           1828
4      Насон Грядущий        3019 
5      Юрий Олеша            1899
6      Николай Чернышевский  1828
7      Андрей Платонов
обы показать только записи, содержащие в определённом поле уникальное значение — применяют оператор DISTINCT
-- ВЫБРАТЬ поля id, name, но только записи с уникальным значением поля birth_year
SELECT DISTINCT on (birth_year) birth_year, id, name
FROM author;  
-- Ответ (только уникальные годы рождения):
id     name                  birth_year
-----  --------------------  ------------
1      Человек без селезёнки 1860
2      Владимир Набоков      1899
3      Лев Толстой           1828
4      Насон Грядущий        3019
Если мы хотим получить какую-то определённую запись, то в запросе надо указать условия. Для этого существует команда WHERE:
-- ВЫБРАТЬ данные из всех колонок ИЗ таблицы author 
-- только в той строке, У КОТОРОЙ в поле id указано значение 3
SELECT * FROM author WHERE id=3;

-- Ответ:
id     name                  birth_year
-----  --------------------  ------------
3      Лев Толстой           1828
Изменение записей: UPDATE
Для обновления данных в существующей записи предназначена команда UPDATE
UPDATE <таблица>
SET <столбец> = <значение>[, <столбец2> = <значение>, ...]
WHERE <условие>;
Чтобы изменить запись с id = 1, можно использовать такой запрос:
-- ОБНОВИТЬ таблицу author 
-- и ЗАПИСАТЬ в поле name значение 'Антон Чехов' 
-- только в той строке, У КОТОРОЙ в поле id указано значение 1
UPDATE author SET name = 'Антон Чехов' WHERE id=1;
Если не указать условие и отправить запрос UPDATE author SET name = 'Антон Чехов', то изменится значение name абсолютно всех записей в таблице: в БД окажутся семь Антонов Чеховых с разными годами рождения.
Посмотрим, как изменились данные в таблице:
-- ОБНОВИТЬ таблицу author и ЗАПИСАТЬ в поле name 
-- значение 'Антон Чехов' в той строке, У КОТОРОЙ в поле id указано 1
UPDATE author SET name = 'Антон Чехов' WHERE id=1;

-- ВЫБРАТЬ данные из всех колонок ИЗ таблицы author в той строке, 
-- У КОТОРОЙ в поле id указано 1
SELECT * FROM author WHERE id=1;

-- Ответ:
id     name                  birth_year
-----  --------------------  ------------
1      Антон Чехов           1860 

-- Порядок, вернули классику настоящее имя
Удаление записей: DELETE
Синтаксис запросов для удаления:
DELETE FROM <таблица> WHERE <условие>;
Как и в случае с UPDATE, условие WHERE имеет очень большое значение: если его не указать, то запрос может удалить вообще все записи в таблице.
Удалим из базы автора, который пока что не входит в список лучших русскоязычных авторов мира и проверим, что получилось.
-- УДАЛИТЬ ИЗ таблицы author запись, У КОТОРОЙ в поле id указано значение 4
DELETE FROM author WHERE id=4;

-- ВЫБРАТЬ данные из всех колонок ИЗ таблицы author
SELECT id, name FROM author;

-- Ответ:
id     name                
-----  --------------------
1      Антон Чехов         
2      Владимир Набоков    
3      Лев Толстой
5      Юрий Олеша
6      Николай Чернышевский
7      Андрей Платонов
--  Насон Грядущий has left the building
Условия запроса: WHERE
WHERE позволяет использовать множество условий одновременно. Для объединения сразу нескольких условий используются операторы AND, OR или NOT, с этими логическими операторами вы уже работали в теме про ветвления.
Пример:
-- ВЫБРАТЬ поля id и name ИЗ ТАБЛИЦЫ author 
-- в записях, У КОТОРЫХ поле birth_year=1860 ИЛИ поле birth_year=1899
SELECT id, name FROM author WHERE birth_year=1860 OR birth_year=1899;

-- Ответ:
id          name       
----------  ----------------
1           Антон Чехов
2           Владимир Набоков
5           Юрий Олеша
7           Андрей Платонов
Такой же запрос можно задать через условие вхождения значения во множество IN:
-- ВЫБРАТЬ поля id и name ИЗ ТАБЛИЦЫ author в записях, 
-- У КОТОРЫХ значение поля birth_year совпадает хотя бы с одним значением В СПИСКЕ (1860,1899)
SELECT id, name FROM author WHERE birth_year IN (1860,1899);

-- Ответ получили такой же:
id          name       
----------  ----------------
1           Антон Чехов
2           Владимир Набоков
5           Юрий Олеша
7           Андрей Платонов
Со скобками можно задать более сложные условия:
SELECT * FROM author WHERE (id < 4 OR id > 5) AND birth_year = 1899;

-- От
вет:
id          name                  birth_year
----------  ----------------      -----------
2           Владимир Набоков      1899
7           Андрей Платонов       1899
Операторы, которые вам понадобятся при составлении запросов:
= это оператор сравнения, а не присваивания.
> , < — больше и меньше, >= , <= — больше или равно и меньше или равно.
<> — не равно. В некоторых базах данных применяется != в качестве оператора неравенства.
BETWEEN — «между», для проверки значения в диапазоне. Например: birth_year BETWEEN 1850 AND 1900.
IN — вхождение в список. Пример использования city IN ('Москва', 'Днепр').
LIKE, ILIKE — поиск строки по шаблону и поиск строки по шаблону без учёта регистра. Пример: city LIKE 'Днепр%', символ % заменяет любой набор символов: такой маске будут соответствовать значения поля ДнепроГЭС, Днепр или Днепровский (а вот «днепровский», с маленькой буквы, не сработает. В этой ситуации нужен оператор ILIKE). Базы данных могут поддерживать и другие маски.
Базы данных могут иметь дополнительные функции или операторы для преобразования строк или поиска с учетом морфологии языка.
Агрегирующие функции. Функция COUNT
В SQL есть функции для подсчёта общего количества строк, суммы, среднего значения, максимума и минимума. Такие функции называют агрегирующие. Они собирают или агрегируют записи (строки таблиц) по заданным условиям и затем проводят над найденными записями какие-то операции.
Пример формата запроса с агрегирующей функцией:
SELECT 
    АГРЕГИРУЮЩАЯ_ФУНКЦИЯ(поле) AS result_name
    -- result_name - имя столбца результирующей выборки
FROM
    ИмяТаблицы;
Оператор SELECT возвращает результат в виде таблицы. В случае с агрегируюющей функцией таблица будет состоять из одной колонки. Имя этой колонки задаётся командой AS (англ. «как»).
Например, агрегирующая функция COUNT() (англ. «подсчёт») возвращает количество строк в таблице:
SELECT 
    -- СОСЧИТАТЬ все строки и вернуть результат В СТОЛБЦЕ ПО ИМЕНИ cnt
    COUNT(*) AS cnt
FROM
    -- ИЗ ТАБЛИЦЫ author
    author;

-- Ответ вернёт результат: "нашлось шесть строк" (Насона Грядущего мы удалили)
cnt  
-----
6
Для того, чтобы найти дату рождения самого старшего автора (запись с наименьшим значением в поле birth_year) применим агрегирующую функцию MIN:
SELECT 
    -- НАЙТИ НАИМЕНЬШЕЕ ЗНАЧЕНИЕ в колонке birth_year 
    -- и вернуть результат В СТОЛБЦЕ ПО ИМЕНИ min_year
    MIN(birth_year) AS min_year
FROM
    author;

-- Ответ (обратите внимание: возвращается результат подсчёта, а не запись):
min_year  
----------
1828
Существуют агрегирующие функции для подсчета числовых значений:
AVG (column) возвращает среднее значение по столбцу column.
Функция SUM(column) возвращает сумму по столбцу column.
В практических заданиях вы будете работать с базой данных товаров и продаж. Информация хранится в таблицах products_data_all и transactions.




















******************************************************************************************************
varchar(n) — строка переменной длины, где n — ограничение. Этот тип данных похож на string в Python, но в отличие от него ограничен по длине: в поле можно занести любую строку короче, чем n символов.
text — строка любой длины. Полный аналог string в Python.


sum(column)

ddl dml

----------add column-------------------
 ALTER TABLE author ADD COLUMN Gender varchar(255);
 
 
 
 
 
 
Чтобы показать только записи, содержащие в определённом поле уникальное значение — применяют оператор DISTINCT
SELECT distinct on (birth_year) birth_year from author;



<> — не равно. В некоторых базах данных применяется != в качестве оператора неравенства.
 SELECT * from author where author.birth_year <> 2005;


BETWEEN — «между», для проверки значения в диапазоне. Например: birth_year BETWEEN 1850 AND 1900.
SELECT * from author where author.birth_year BETWEEN 2004 and 2006;




LIKE, ILIKE — поиск строки по шаблону и поиск строки по шаблону без учёта регистра. Пример: city LIKE 'Днепр%', символ % заменяет любой набор символов: такой маске будут соответствовать значения поля ДнепроГЭС, Днепр или Днепровский (а вот
«днепровский», с маленькой буквы, не сработает. 
SELECT * from author where author.name LIKE 'Di%';

 SELECT * from author where author.name ILIKE 'DI%';












SELECT 
  -- Поля, которые мы хотим получить в ответе
  author.name,
  book.title,
  book.year
FROM 
  -- Таблицы, из которых запрашиваем данные:
  author,
  book
WHERE
  -- В таблице book найти строки, в которых поле year содержит "1886"
  book.year = 1886 
  AND 
  -- И значение поля book.author_id должно быть равно значению author.id
  book.author_id = author.id;



Аналогичный запрос с ключевым словом JOIN выглядит так:
SELECT 
-- ВЫБРАТЬ данные из колонок //указываем имена колонок вместе с именем таблицы//
    author.name,
    book.title,
    book.year
FROM 
    -- Запрашиваем данные ИЗ ТАБЛИЦЫ author
    author
-- к результатам ПРИСОЕДИНИТЬ данные из таблицы book
JOIN book
    -- показать только те записи, в которых
    -- значение поля book.author_id равно значению поля author.id
    ON book.author_id = author.id
WHERE
    -- из всего найденного показать только те результаты, 
    -- где значение поля book.year равно "1886"
    book.year = 1886;
    
    
*****************************************************************


SELECT * FROM test2 WHERE name  ILIKE '%____%';
    
    
    
    
create table prod(maker varchar(10) NOT NULL, model varchar(50) NOT NULL PRIMARY KEY);
CREATE TABLE
ITC=# \d prod
ITC=# create table pc(code int NOT NULL PRIMARY KEY, model varchar(50) REFERENCES prod(model));









*******************************************************```        
CREATE TABLE Products
(
    Id SERIAL PRIMARY KEY,
    ProductName VARCHAR(30) NOT NULL,
    Company VARCHAR(20) NOT NULL,
    ProductCount INT DEFAULT 0,
    Price NUMERIC NOT NULL,
    IsDiscounted BOOL
);
   
INSERT INTO Products (ProductName, Company, ProductCount, Price, IsDiscounted) 
VALUES
('iPhone X', 'Apple', 3, 76000, false),
('iPhone 8', 'Apple', 2, 71000, true),
('iPhone 7', 'Apple', 5, 42000, true),
('Galaxy S9', 'Samsung', 2, 46000, false),
('Galaxy S8 Plus', 'Samsung', 1, 56000, true),
('Desire 12', 'HTC', 5, 28000, true),
('Nokia 9', 'HMD Global', 6, 38000, true);
postgres=# SELECT author2.id, author2.name, author2.birth_year, spouse.name  AS spouse_name, spouse.wed_year, book.title AS book_name, book.year FROM author2
postgres-# INNER JOIN spouse 
postgres-# ON spouse.author_id = author2.id 
postgres-# INNER JOIN book 
postgres-# ON spouse.author_id = book.author_id;
